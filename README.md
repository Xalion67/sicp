# Задания из курса СИКП в Массачусетском технологическом институте
Оригинальный курс изучается на языке Scheme, по-русски — Ским.  
Некоторые задания не имеют смысла, если делать их на другом языке программирования,
поэтому такие задания сделаны на нём, остальные – на Пайтоне и С++

## [Задание 1.2](/chapter_1/1.2/expression.scm)
Перевести выражение в префиксную форму

![Картинка выражения](/chapter_1/1.2/expression.png)

**Решение**  
**_Язык: Ским_**
```scm
(/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5)))))
   (* 3 (- 6 2) (- 2 7)))
```
> Результат => -0.24666666666666667

## [Задание 1.3](/chapter_1/1.3)
Написать процедуру, которая принимает три числа и возвращает сумму квадратов двух больших чисел.

**Решение  
_Язык: Пайтон_**
```py
def sum_of_squares_of_top_two(a, b, c):
    if a < b and a < c:
        return b ** 2 + c ** 2
    elif b < a and b < c:
        return a ** 2 + c ** 2
    else:
        return a ** 2 + b ** 2

```
**_Язык: С++_**
```c++
int sum_of_squares_of_two_top(int a, int b, int c) {
  if (a < b && a < c) {
    return square(b) + square(c);
  }
  else if (b < c && b < a) {
    return square(a) + square(c);
  }
  else {
    return square(a) + square(b);
  }
}
```
## [Задание 1.4](/chapter_1/1.4/add-with-abs.scm)
Как работает процедура `a-plus-abs-b`
```scm
(define (a-plus-abs-b a b)
  ((if (> b 0) + -) a b))
```

**Решение**  
Может быть только два варианта: `b > 0` и `b <= 0`  
1. `b > 0`.  
Из условия возвращается `+`, тело функции вычисляется в `a + b`  
2. `b <= 0`.  
Из условия возвращается `-`, тело функции вычисляется в `a - (-b) = a + b`  

Эта процедура описывает сложение `a` с модулем `b`, она работает потому что для
скима плюс и минус такие же структуры языка, как переменные.


## [Задание 1.5](/chapter_1/1.5/)
В МИТе придумали тест для интерпретатора. После его выполнения становится понятно с каким порядком
вычислений работает интерпретатор.  

**Решение**  
**_Язык: Пайтон_**
```py
def p():
    return p()


def test(x, y):
    if x == 0:
        return 0
    return y


test(0, p())

```

**_Язык: С++_**  
```cpp
int p() {
  return p();
}

int test(int x, int y) {
  if (x == 0) {
    return 0;
  }
  return y;
}

int main() {
  test(0, p());

  return 0;
}
```

**_Язык: Ским_**  
```scm
(define (p) (p))

(define (test x y) 
  ((if (= x 0) 0 y))
)

(test 0 (p))
```


Если интерпретатор работает с апликативным порядком вычислений, то он упадет от бесконечной рекурсии.  
Прежде чем выполнять тело функции, он попытается вычислить рекурсивную функцию `p`.  

Если интерпретатор работает с нормальным порядком вычислений, то он вернёт ноль.
Он сразу зайдет в тело функции, проверка в условии вернёт истину и функция вернёт ноль.


## [Задание 1.6]()  
В этом задании понимаешь почему `if` должна быть особой формой, а не обычной функцией написанной через `cond`, это условная конструкция в скиме для вычисления нескольких условий.  
Код функции `if` через `cond`
```scm
(define (new-if predicate then-clause else-clause)
  (cond (predicate then-clause)
        (else else-clause))
)
```

Проверяем, вроде всё работает  
`(new-if (= 2 3) 5 0)` => 0  
`(new-if (< 2 3) 5 0)` => 5

Переписываем программу для вычисления квадратного корня через `new-if`.
> Это часть кода для вычисления квадратного корня, [полный код в задании 1.7]()
```scm
(define (sqrt-iter guess x)
  (new-if (good-enough? guess x)
          guess
          (sqrt-iter (improve guess x) x)
  )
)
```

**Решение**  
В итоге интерпретатор упадет от бесконечной рекурсии, потому что работает с апликативным порядком вычислений.  
Прежде чем выполнять тело функции `new-if`, он попытается вычислить все аргументы и начнёт бесконечно вызывать функцию `sqrt-iter`

## [Задание 1.7](/chapter_1/1.7)
Функция для вычисления корня написана чтобы объяснить процедурную абстракцию, как черный ящик и блочную структуру.
Её первый вариант выглядит вот так
```
def sqrt(x):
    return sqrt_iter(1.0, 0.5, x)


def sqrt_iter(guess, previous_guess, x):
    if good_enough(guess, previous_guess):
        return guess
    return sqrt_iter(improve(guess, x), guess, x)


def good_enough(guess, previous_guess):
    if abs((guess - previous_guess) / previous_guess) < 0.001:
        return True
    return False


def improve(guess, x):
    return average(guess, x / guess)


def average(x, y):
    return (x + y) / 2

```

Но здесь есть недостаток: она вычисляет неправильный квадратный корень для слишком маленьких и больших чисел, ещё все дополнительные функции написаны снаружи.  
Это можно решить изменением функции `good_enough` и блочной структурой. Вместо возведения догадки в квадрат, можно смотреть насколько она изменяется с каждым шагом и остановить функцию когда изменение будет слишком маленькое.  
Теперь функция выглядит вот так
```
def sqrt(x):
    def sqrt_iter(guess, previous_guess):
        if good_enough(guess, previous_guess):
            return guess
        return sqrt_iter(improve(guess), guess)

    def good_enough(guess, previous_guess):
        if abs((guess - previous_guess) / previous_guess) < 0.001:
            return True
        return False

    def improve(guess):
        return average(guess, x / guess)

    def average(x, y):
        return (x + y) / 2

    return sqrt_iter(1.0, 0.5)

```

## [Задание 1.8]()
Метод Ньютона позволяет находить разные виды корней.  
Частный случай для квадратного корня мы написал, теперь напишем функцию для вычисления кубического корня.  
Вычисление догадки для кубического корня выглядит так  

Теперь нам нужно просто изменить расчет догадки в функции `improve` и убрать функцию `average`, потому что среднее арифметическое нам больше не нужно.  
`code`
